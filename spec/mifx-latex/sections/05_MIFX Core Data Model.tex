\section{MIFX Core Data Model}

This section defines the normative structure of a MIFX package.

MIFX uses a modular JSON document model.
Each primary entity (Job, Setup, Operation, Tool) is defined in a separate JSON file.
Relationships are expressed through identifiers and relative path references.

Semantic order SHALL be defined explicitly by array order within referencing documents.
No execution graph, dependency model, or behavioral semantics are defined.

\subsection{Package Entry Point}

Every MIFX archive SHALL contain a file named \texttt{job.json} at the root of the archive.

The \texttt{job.json} file defines:

\begin{itemize}
    \item global metadata,
    \item global unit definition,
    \item ordered references to Setup documents,
    \item optional global artifact references.
\end{itemize}

Exactly one \texttt{job.json} SHALL exist per archive.

\subsection{Job Structure}

The Job document SHALL contain:

\begin{itemize}
    \item \texttt{exportVersion}
    \item \texttt{header}
    \item \texttt{units}
    \item \texttt{setups} (ordered array of setup references)
\end{itemize}

The \texttt{setups} array order SHALL define semantic Setup order.

\subsection{Setup Definition}

Each Setup SHALL be defined as a separate JSON document within the \texttt{setup/} directory.

A Setup definition SHALL contain:

\begin{itemize}
    \item \texttt{id} (unique within the Job)
    \item optional transformation matrix
    \item ordered array of Operation references
\end{itemize}

Operation order SHALL be defined by array position.

If no transformation is defined, identity SHALL be assumed.

\subsection{Operation Definition}

Each Operation SHALL be defined as a separate JSON document within the \texttt{operations/} directory.

An Operation SHALL contain:

\begin{itemize}
    \item \texttt{id} (unique within the Job)
    \item \texttt{setupRef}
    \item optional \texttt{toolRef}
    \item optional \texttt{cuttingConditions}
    \item optional \texttt{artifactRefs}
\end{itemize}

Operations SHALL NOT imply execution behavior.

\subsection{Tool Definition}

Tools SHALL be defined as JSON documents within \texttt{geometry/tooling/}.

A Tool definition SHALL contain:

\begin{itemize}
    \item \texttt{toolNumber}
    \item \texttt{toolType}
    \item optional dimensional attributes
    \item optional extension metadata
\end{itemize}

Tool identifiers SHALL be referenced by Operations via \texttt{toolRef}.

Optional visualization geometry (e.g., STL) MAY be referenced explicitly via artifact references.

\subsection{Artifact References}

Artifacts SHALL be referenced using explicit relative paths.

An artifact reference SHALL contain:

\begin{itemize}
    \item \texttt{role}
    \item \texttt{kind}
    \item \texttt{path}
    \item optional \texttt{present}
\end{itemize}

Example:

\begin{verbatim}
{
  "role": "toolpath",
  "kind": "apt",
  "path": "cldata/op-1.apt",
  "present": true
}
\end{verbatim}

Artifact resolution SHALL NOT rely on directory inference rules.
The \texttt{path} value SHALL be authoritative.

If \texttt{present} is \texttt{true}, the referenced file SHALL exist within the archive.
If \texttt{present} is omitted or \texttt{false}, the file MAY be absent.

Artifacts SHALL NOT redefine structural semantics.

\subsection{Toolpath Artifact}

For toolpath artifacts:

\begin{itemize}
    \item \texttt{role} SHALL be \texttt{"toolpath"}
    \item \texttt{kind} SHALL be \texttt{"apt"} or \texttt{"cl"}
    \item the referenced file SHALL reside within \texttt{cldata/}
\end{itemize}

Toolpath artifacts are informational and non-normative with respect to execution.

\subsection{CuttingConditions}

An Operation MAY define cutting conditions:

\begin{verbatim}
{
  "cuttingConditions": {
    "spindleDir": "CW",
    "spindle": { "value": 12000, "unit": "rpm" },
    "feed": { "value": 350, "unit": "mm/min" },
    "coolant": "through_tool"
  }
}
\end{verbatim}

These values represent declared intent only and SHALL NOT define controller behavior.

No inheritance model is defined.

\subsection{Determinism}

A conforming MIFX consumer SHALL be able to:

\begin{itemize}
    \item parse \texttt{job.json},
    \item reconstruct Setup order from the \texttt{setups} array,
    \item reconstruct Operation order from Setup references,
    \item resolve Tool references,
    \item resolve artifact paths deterministically.
\end{itemize}

A conforming consumer SHALL produce identical structural interpretation
given identical archive contents.

Consumers SHALL NOT infer implicit relationships beyond those explicitly defined.

MIFX defines structure and relationships only.
It does not define execution behavior, simulation models,
controller syntax, or lifecycle management.